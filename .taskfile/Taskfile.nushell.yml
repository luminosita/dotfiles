version: '3'

# Setup Script - Development Tasks
# Consolidated CLI interface for all development operations

vars:
  VERSION: "v$(cat VERSION)"
  VERSION_SNAPSHOT: "v$(cat VERSION)-snapshot"
  REGISTRY: docker.io/luminosita
  CONTAINER_IMAGE_NAME: "{{.REGISTRY}}/{{.IMAGE_NAME}}:{{.VERSION}}"
  CONTAINER_IMAGE_NAME_SNAPSHOT: "{{.REGISTRY}}/{{.IMAGE_NAME}}:{{.VERSION_SNAPSHOT}}"
  CONTAINER_IMAGE_NAME_LATEST: "{{.REGISTRY}}/{{.IMAGE_NAME}}:latest"
  CONTAINER_TOOL: podman
  INCLUDE_LATEST: "false"
  TALOS_VERSION: v1.12.1
  TALOS_CONTROL_PLANE_RAM: 4.0GiB
  TALOS_CONTROL_PLANE_IP: 10.5.0.2
  TALOS_CONTROL_PLANE_CIDR: "{{.TALOS_CONTROL_PLANE_IP}}/24"
  TALOS_GATEWAY_IP: 10.5.0.1
  TALOS_DEFAULT_ROUTE: 10.0.0.0/8
  TALOS_SUBNET: 10.5.0.0/24
  TALOS_IMAGE_FACTORY_API_URL: https://factory.talos.dev/schematics

tasks:
  check:
    desc: Run pre-commit checks (tests and linting)
    deps:
      - check:devbox
    cmds:
      - task: test:verbose
      - task: hooks:run

  check:devbox:
    desc: Verify running inside devbox shell
    internal: true
    silent: true
    cmds:
      - |
        if [ -z "$DEVBOX_SHELL_ENABLED" ]; then
          echo "‚ùå Error: Not running in devbox shell"
          echo "   Run 'devbox shell' first to enter the development environment"
          exit 1
        fi

  build:
    desc: "Build standalone setup script and container images"
    silent: true
    deps:
      - task: build:assembly

  build:scripts:
    desc: "Build standalone setup script (all languages)"
    deps:
      - check:devbox
    silent: true
    internal: true 
    cmds:
      - rm -rf dist && mkdir -p dist
      - for: { var: SCRIPTS }
        cmd: |
          echo "Building {{.ITEM}}..."
          nu cmd/build.nu --yes --main-script cmd/{{.ITEM}} --output dist/{{.ITEM}}

  build:assembly:
    desc: "Build standalone setup script and container images"
    silent: true
    deps:
      - task: build:scripts
        vars:
          SCRIPTS: ['setup.nu']
    cmds:
      - |
        mkdir -p dist/default/assembly
        cp dist/setup.nu dist/default/setup.nu

  # ====================
  # Tests
  # ====================

  test:
    desc: Run all unit tests with summary reporting
    cmds:
      - task: test:unit 
        vars:
          CLI_ARGS: "--verbose {{.CLI_ARGS}}"

  test:verbose:
    desc: Run all unit tests with detailed assertion reporting
    cmds:
      - task: test
        vars:
          CLI_ARGS: "--verbose {{.CLI_ARGS}}"

  test:unit:
    desc: Run unit tests only with summary reporting
    deps:
      - check:devbox
    cmds:
      - nu lib/shared/test.nu --unit {{.CLI_ARGS}}

  test:unit:verbose:
    desc: Run unit tests only with detailed assertion reporting
    cmds:
      - task: test:unit
        vars:
          CLI_ARGS: "--verbose {{.CLI_ARGS}}"

  # ====================
  # Integration Tests
  # ====================

  test:integration:
    desc: Run only previously failed tests
    cmds:
      - nu lib/shared/test.nu --integration {{.CLI_ARGS}}

  test:integration:verbose:
    desc: Run only previously failed tests with detailed reporting
    cmds:
      - task: test:integration
        vars:
          CLI_ARGS: "--verbose {{.CLI_ARGS}}"

  test:integration:cluster:
    cmds:
      - task: test:kind:start
      - defer: { task: test:kind:stop }
      - task: test:integration
        vars:
          CLI_ARGS: "{{.CLI_ARGS}}"

  test:integration:cluster:verbose:
    desc: Run integration tests with verbose output (create ‚Üí test ‚Üí teardown) | Pass extra args with -- (e.g., task test:integration:verbose -- --failed)
    cmds:
      - task: test:integration:cluster
        vars:
          CLI_ARGS: "--verbose {{.CLI_ARGS}}"

  # ====================
  # Failed Tests
  # ====================

  test:failed:
    desc: Run only previously failed tests
    cmds:
      - nu lib/shared/test.nu --failed {{.CLI_ARGS}}

  test:failed:verbose:
    desc: Run only previously failed tests with detailed reporting
    cmds:
      - task: test:failed
        vars:
          CLI_ARGS: "--verbose {{.CLI_ARGS}}"

  test:failed:cluster:
    desc: Run end-to-end tests with cluster lifecycle (build ‚Üí create ‚Üí test ‚Üí teardown) | Pass extra args with -- (e.g., task test:e2e -- --failed)
    cmds:
      - task: test:kind:start
      - defer: { task: test:kind:stop }
      - task: test:failed
        vars:
          CLI_ARGS: "{{.CLI_ARGS}}"

  test:failed:cluster:verbose:
    desc: Run end-to-end tests with verbose output (build ‚Üí create ‚Üí test ‚Üí teardown) | Pass extra args with -- (e.g., task test:e2e:verbose -- --failed)
    cmds:
      - task: test:failed:cluster
        vars:
          CLI_ARGS: "--verbose {{.CLI_ARGS}}"


  # ====================
  # E2E Tests
  # ====================

  test:e2e:
    desc: Run end-to-end tests with verbose output (build ‚Üí create ‚Üí test ‚Üí teardown) | Pass extra args with -- (e.g., task test:e2e:verbose -- --failed)
    deps:
      - task: release:snapshot:package
    cmds:
      - nu lib/shared/test.nu --e2e {{.CLI_ARGS}}

  test:e2e:verbose:
    desc: Run end-to-end tests with cluster lifecycle (build ‚Üí create ‚Üí test ‚Üí teardown) | Pass extra args with -- (e.g., task test:e2e -- --failed)
    cmds:
      - task: test:e2e
        vars:
          CLI_ARGS: "--verbose {{.CLI_ARGS}}"

  test:e2e:cluster:
    desc: Run end-to-end tests with cluster lifecycle (build ‚Üí create ‚Üí test ‚Üí teardown) | Pass extra args with -- (e.g., task test:e2e -- --failed)
    cmds:
      - task: test:kind:start
      - defer: { task: test:kind:stop }
      - task: test:e2e
        vars:
          CLI_ARGS: "{{.CLI_ARGS}}"

  test:e2e:cluster:verbose:
    desc: Run end-to-end tests with verbose output (build ‚Üí create ‚Üí test ‚Üí teardown) | Pass extra args with -- (e.g., task test:e2e:verbose -- --failed)
    cmds:
      - task: test:e2e:cluster
        vars:
          CLI_ARGS: "--verbose {{.CLI_ARGS}}"

  # ====================
  # Kind Cluster
  # ====================
  test:kind:start:
    desc: Create kind cluster for integration tests (kubeconfig saved to ./tmp/, uses podman)
    deps:
      - check:devbox
    cmds:
      - mkdir -p out
      - export KIND_EXPERIMENTAL_PROVIDER=podman && kind create cluster --name k8s-test --config tests/integration/kind-config.yaml --kubeconfig $(pwd)/out/kubeconfig
      - kubectl delete storageclass standard --kubeconfig $(pwd)/out/kubeconfig
      - kubectl delete ns local-path-storage --kubeconfig $(pwd)/out/kubeconfig

  test:kind:stop:
    desc: Delete kind cluster for integration tests and clean up kubeconfig
    deps:
      - check:devbox
    cmds:
      - (export KIND_EXPERIMENTAL_PROVIDER=podman && kind delete cluster --name k8s-test) || true
      - rm -rf tmp/kubeconfig

  test:kind:restart:
    desc: Delete kind cluster for integration tests and clean up kubeconfig
    cmds:
      - task: test:kind:stop
      - task: test:kind:start

  # ====================
  # Talos Cluster
  # ====================
  test:talos:patch:
    cmds:
      - |
        mkdir -p out
        BOOTSTRAP_MANIFEST=$(kustomize build {{.TALOS_BOOTSTRAP_KUSTOMIZATION_DIR}} | jq -Rs .)
        TEMPLATE_VARS=$(cat <<EOF
        {
          "bootstrapManifest": $BOOTSTRAP_MANIFEST,
          "gateway": "{{.TALOS_GATEWAY_IP}}",
          "node_ip": "{{.TALOS_CONTROL_PLANE_CIDR}}",
          "subnet": "{{.TALOS_SUBNET}}",
          "route": "{{.TALOS_DEFAULT_ROUTE}}"
        }
        EOF
        )
        echo $TEMPLATE_VARS | gomplate -d 'config=stdin://?type=application/json' -f {{.TALOS_PATCH_FILE}} -o ./out/talos-patch.yaml

  test:talos:schematic:
    cmds:
      - mkdir -p out
      - curl -s -X POST --data-binary @{{.TALOS_SCHEMATIC}} {{.TALOS_IMAGE_FACTORY_API_URL}} | jq -r '.id' > ./out/TALOS_SCHEMATIC_ID

  test:talos:start:
    desc: Create kind cluster for integration tests (kubeconfig saved to ./out/, uses podman)
    deps:
      - check:devbox
      - task: test:talos:patch
      - task: test:talos:schematic
    cmds:
      - |
        # Changing working dir to avoid creation of talos config files in project root
        cd ./out && rm -f talosconfig && rm -f kubeconfig
        (sudo talosctl cluster create qemu \
          --schematic-id=$(cat ./TALOS_SCHEMATIC_ID) \
          --talos-version={{.TALOS_VERSION}} \
          --controlplanes=1 \
          --workers=0 \
          --talosconfig-destination=./talosconfig \
          --config-patch-controlplanes @./talos-patch.yaml \
          --presets disk-image \
          --memory-controlplanes {{.TALOS_CONTROL_PLANE_RAM}} && \
          echo "‚úÖ Talos cluster deployed") || true
      - |
        echo "üì¶ Generating cluster configuration files ..."
        sudo chown $USER out/talosconfig
        export TALOSCONFIG=./out/talosconfig
        export KUBECONFIG=./out/kubeconfig
        talosctl config nodes {{.TALOS_CONTROL_PLANE_IP}}
        talosctl kubeconfig ./out/kubeconfig
        echo "‚úÖ Talos cluster ready"

  test:talos:stop:
    desc: Delete kind cluster for integration tests and clean up kubeconfig
    deps:
      - check:devbox
    cmds:
      - sudo talosctl cluster destroy

  test:talos:restart:
    desc: Delete kind cluster for integration tests and clean up kubeconfig
    cmds:
      - task: test:talos:stop
      - task: test:talos:start

  # ====================
  # Containers
  # ====================
  containers:build:
    desc: "Build container image and tag with version"
    deps:
      - build:assembly
    silent: true
    cmds:
      - echo "üê≥ Building container image..."
      - |
        echo "üì¶ Using {{.CONTAINER_TOOL}} to build image..."
        echo "   REGISTRY: {{.REGISTRY}}"
        echo "   Image: {{.IMAGE_NAME}}"
        echo "   Version: {{.VERSION}}"

        # Build image from Containerfile
        {{.CONTAINER_TOOL}} build \
          -f {{.FILE}} \
          -t "{{.CONTAINER_IMAGE_NAME}}" \
          {{.DIR}}
        echo "‚úÖ Container image built successfully"
        echo "   - {{.CONTAINER_IMAGE_NAME}}"

  containers:build:snapshot:
    cmds:
      - task: containers:build
        vars:
          VERSION: "{{.VERSION_SNAPSHOT}}"

  containers:push:
    desc: "Push container image to Docker Hub"
    deps:
      - check:devbox
    silent: true
    cmds:
      - echo "üöÄ Pushing container image to Docker Hub..."
      - |
        {{if eq .INCLUDE_LATEST "true"}}
        {{.CONTAINER_TOOL}} tag "{{.CONTAINER_IMAGE_NAME}}" "{{.CONTAINER_IMAGE_NAME_LATEST}}"
        echo "   - {{.CONTAINER_IMAGE_NAME}} ‚Üí {{.CONTAINER_IMAGE_NAME_LATEST}}"
        {{end}}
      - |
        echo "üì§ Using {{.CONTAINER_TOOL}} to push image..."
        echo "   Image: {{.CONTAINER_IMAGE_NAME}}"

        # Push to Docker Hub
        {{.CONTAINER_TOOL}} push "{{.CONTAINER_IMAGE_NAME}}"
        echo "‚úÖ Container images pushed successfully"
        echo "   - {{.CONTAINER_IMAGE_NAME}}"

        {{if eq .INCLUDE_LATEST "true"}}
        echo "üì§ Pushing latest tag..."
        {{.CONTAINER_TOOL}} push "{{.CONTAINER_IMAGE_NAME_LATEST}}"
        echo "   - {{.CONTAINER_IMAGE_NAME_LATEST}}"
        {{end}}

  containers:push:snapshot:
    cmds:
      - task: containers:push
        vars:
          CONTAINER_IMAGE_NAME: "{{.CONTAINER_IMAGE_NAME_SNAPSHOT}}"

  containers:push:latest:
    cmds:
      - task: containers:push
        vars:
          INCLUDE_LATEST: "true"

  # ====================
  # Pre-commit Hooks
  # ====================

  hooks:install:
    desc: Install pre-commit hooks for Go (using pre-commit framework)
    cmds:
      - pre-commit install

  hooks:run:
    desc: Run pre-commit hooks manually on all files
    cmds:
      - pre-commit run --all-files

  hooks:update:
    desc: Update pre-commit hooks to latest versions
    cmds:
      - pre-commit autoupdate
      - echo "‚úÖ Pre-commit hooks updated"

  hooks:uninstall:
    desc: Uninstall pre-commit hooks
    cmds:
      - pre-commit uninstall
      - echo "‚úÖ Pre-commit hooks uninstalled"

# ====================
# Release Management
# ====================
  release:prepare:
    desc: "Prepare release (run tests and checks before release)"
    cmds:
      - echo "üîç Running pre-release checks..."
      - task: check
      - echo "‚úÖ Release preparations complete"

  release:dry-run:
    internal: true
    desc: "Dry-run stable release (preview without publishing)"
    cmds:
      - task: release
        vars:
          CLI_ARGS: "--dry-run {{.CLI_ARGS}}"

  release:snapshot:dry-run:
    desc: "Dry-run snapshot release (preview without publishing)"
    cmds:
      - task: release:snapshot
        vars:
          CLI_ARGS: "--dry-run {{.CLI_ARGS}}"

  release:
    desc: "Create stable release to Codeberg (production version, stable release)"
    deps:
      - release:prepare
      - build:assembly
    cmds:
      - echo "üì¶ Creating release to Codeberg..."
      - jreleaser-cli full-release -c .jreleaser.yml --strict {{.CLI_ARGS}}
      - echo "‚úÖ Stable release complete"

  release:snapshot:
    desc: "Create snapshot release to Codeberg (development version, pre-release)"
    deps:
      - build:assembly
    cmds:
      - echo "üì¶ Creating snapshot release to Codeberg..."
      - jreleaser-cli full-release -c .jreleaser.snapshot.yml {{.CLI_ARGS}}
      - echo "‚úÖ Snapshot release complete"

  release:package:
    deps:
      - build:assembly
    cmds:
      - echo "üì¶ Creating package ..."
      - jreleaser-cli package -c .jreleaser.yml --strict {{.CLI_ARGS}}
      - echo "‚úÖ Snapshot complete"

  release:package:snapshot:
    desc: "Create snapshot package"
    deps:
      - build:assembly
    cmds:
      - echo "üì¶ Creating snapshot package ..."
      - jreleaser-cli package -c .jreleaser.snapshot.yml {{.CLI_ARGS}}
      - echo "‚úÖ Snapshot package complete"

  release:changelog:
    desc: "Generate changelog for commits since last release"
    deps:
      - check:devbox
    cmds:
      - echo "üìù Generating changelog..."
      - jreleaser-cli changelog {{.CLI_ARGS}}
      - echo "‚úÖ Changelog generated"

# ====================
# Misc
# ====================
  default:
    desc: Show available tasks
    cmds:
      - task -a
